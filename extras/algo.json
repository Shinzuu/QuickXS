{
  "topics": [
    {
      "topic": "Merge Sort",
      "questions": [
        {
          "question": "What is the main advantage of Merge Sort over other sorting algorithms?",
          "choices": [
            "A) It is always faster than other algorithms",
            "B) It guarantees stable sorting",
            "C) It requires less memory",
            "D) It is easier to implement"
          ],
          "answer": "B"
        },
        {
          "question": "What is the time complexity of Merge Sort in the worst case?",
          "choices": [
            "A) O(n)",
            "B) O(n log n)",
            "C) O(n^2)",
            "D) O(log n)"
          ],
          "answer": "B"
        },
        {
          "question": "What is the space complexity of Merge Sort?",
          "choices": [
            "A) O(1)",
            "B) O(n)",
            "C) O(n log n)",
            "D) O(log n)"
          ],
          "answer": "B"
        },
        {
          "question": "Which of the following best describes the process of Merge Sort?",
          "choices": [
            "A) Divide and conquer",
            "B) Dynamic programming",
            "C) Greedy algorithm",
            "D) Brute-force search"
          ],
          "answer": "A"
        },
        {
          "question": "In which case is Merge Sort particularly useful?",
          "choices": [
            "A) When data is mostly sorted",
            "B) When dealing with large datasets",
            "C) When data is in random order",
            "D) When data is of small size"
          ],
          "answer": "B"
        },
        {
          "question": "What is the key operation performed in the Merge step of Merge Sort?",
          "choices": [
            "A) Merging two sorted arrays",
            "B) Swapping elements",
            "C) Reversing the order",
            "D) Finding the median"
          ],
          "answer": "A"
        },
        {
          "question": "Which of the following statements about Merge Sort is true?",
          "choices": [
            "A) It is an in-place sorting algorithm",
            "B) It is not stable",
            "C) It works well with linked lists",
            "D) It is not recursive"
          ],
          "answer": "C"
        }
      ]
    },
    {
      "topic": "Quick Sort",
      "questions": [
        {
          "question": "What is the main advantage of Quick Sort?",
          "choices": [
            "A) It is always stable",
            "B) It is typically faster than Merge Sort",
            "C) It requires less memory",
            "D) It is easier to implement"
          ],
          "answer": "B"
        },
        {
          "question": "Which of the following is a common pivot selection method in Quick Sort?",
          "choices": [
            "A) First element",
            "B) Last element",
            "C) Median of three",
            "D) Random element"
          ],
          "answer": "C"
        },
        {
          "question": "What is the average time complexity of Quick Sort?",
          "choices": [
            "A) O(n)",
            "B) O(n log n)",
            "C) O(n^2)",
            "D) O(log n)"
          ],
          "answer": "B"
        },
        {
          "question": "What happens in the partitioning step of Quick Sort?",
          "choices": [
            "A) The array is split into two halves",
            "B) Elements are rearranged around the pivot",
            "C) The smallest element is found",
            "D) The largest element is found"
          ],
          "answer": "B"
        },
        {
          "question": "Which of the following is true about Quick Sort?",
          "choices": [
            "A) It is not suitable for large datasets",
            "B) It can be implemented using recursion",
            "C) It is always stable",
            "D) It requires extra space"
          ],
          "answer": "B"
        },
        {
          "question": "What is the worst-case time complexity of Quick Sort?",
          "choices": [
            "A) O(n)",
            "B) O(n log n)",
            "C) O(n^2)",
            "D) O(log n)"
          ],
          "answer": "C"
        },
        {
          "question": "Which of the following scenarios can lead to poor performance in Quick Sort?",
          "choices": [
            "A) Selecting the median as a pivot",
            "B) Already sorted arrays",
            "C) Randomized pivot selection",
            "D) Large datasets"
          ],
          "answer": "B"
        }
      ]
    },
    {
      "topic": "Huffman Coding",
      "questions": [
        {
          "question": "What is the primary application of Huffman Encoding?",
          "choices": [
            "A) Sorting data",
            "B) Image processing",
            "C) Data compression",
            "D) Pathfinding"
          ],
          "answer": "C"
        },
        {
          "question": "In Huffman Coding, how is the most frequent character represented?",
          "choices": [
            "A) With the longest code",
            "B) With the shortest code",
            "C) With a fixed-length code",
            "D) With a variable-length code"
          ],
          "answer": "B"
        },
        {
          "question": "What data structure is primarily used in Huffman Coding?",
          "choices": [
            "A) Linked list",
            "B) Hash table",
            "C) Heap",
            "D) Binary tree"
          ],
          "answer": "D"
        },
        {
          "question": "Which of the following statements about Huffman Coding is true?",
          "choices": [
            "A) It is a lossy compression technique",
            "B) It can only be used for text files",
            "C) It is a prefix code",
            "D) It requires more memory than other methods"
          ],
          "answer": "C"
        },
        {
          "question": "What is the time complexity of constructing a Huffman Tree?",
          "choices": [
            "A) O(n)",
            "B) O(n log n)",
            "C) O(log n)",
            "D) O(n^2)"
          ],
          "answer": "B"
        },
        {
          "question": "In Huffman Coding, what does a 'leaf node' represent?",
          "choices": [
            "A) A character and its frequency",
            "B) The root of the tree",
            "C) An internal node with two children",
            "D) A temporary placeholder"
          ],
          "answer": "A"
        },
        {
          "question": "Which of the following is a disadvantage of Huffman Coding?",
          "choices": [
            "A) It is simple to implement",
            "B) It requires a lot of memory",
            "C) It is not optimal for small files",
            "D) It can be decoded easily"
          ],
          "answer": "C"
        }
      ]
    },
    {
      "topic": "Fractional Knapsack",
      "questions": [
        {
          "question": "What is the main characteristic of the Fractional Knapsack problem?",
          "choices": [
            "A) Items cannot be divided",
            "B) Only one item can be chosen",
            "C) Items can be divided into smaller parts",
            "D) All items must be chosen"
          ],
          "answer": "C"
        },
        {
          "question": "What is the optimal strategy for the Fractional Knapsack problem?",
          "choices": [
            "A) Take the heaviest item first",
            "B) Take the lightest item first",
            "C) Take items based on their value-to-weight ratio",
            "D) Take items in random order"
          ],
          "answer": "C"
        },
        {
          "question": "What type of algorithm is typically used for solving the Fractional Knapsack problem?",
          "choices": [
            "A) Dynamic programming",
            "B) Greedy algorithm",
            "C) Backtracking",
            "D) Brute-force search"
          ],
          "answer": "B"
        },
        {
          "question": "In the Fractional Knapsack problem, if an item cannot be fully taken, what should be done?",
          "choices": [
            "A) Leave it behind",
            "B) Take as much as possible",
            "C) Discard it completely",
            "D) Take the whole item regardless"
          ],
          "answer": "B"
        },
        {
          "question": "What is the time complexity for the Fractional Knapsack problem when using a greedy approach?",
          "choices": [
            "A) O(n log n)",
            "B) O(n^2)",
            "C) O(n)",
            "D) O(1)"
          ],
          "answer": "A"
        },
        {
          "question": "Which of the following is an important consideration in the Fractional Knapsack problem?",
          "choices": [
            "A) Total weight of items",
            "B) Total number of items",
            "C) Total value of items",
            "D) All of the above"
          ],
          "answer": "D"
        },
        {
          "question": "What is the optimal solution of the Fractional Knapsack problem?",
          "choices": [
            "A) The highest total weight",
            "B) The highest total value",
            "C) A balance of weight and value",
            "D) The lowest total weight"
          ],
          "answer": "B"
        }
      ]
    },
    {
      "topic": "Prim's Algorithm",
      "questions": [
        {
          "question": "What is the primary purpose of Prim's Algorithm?",
          "choices": [
            "A) Finding the shortest path in a graph",
            "B) Finding the maximum flow in a network",
            "C) Finding the minimum spanning tree of a graph",
            "D) Sorting a list of elements"
          ],
          "answer": "C"
        },
        {
          "question": "What data structure is commonly used in Prim's Algorithm?",
          "choices": [
            "A) Stack",
            "B) Queue",
            "C) Array",
            "D) Priority queue"
          ],
          "answer": "D"
        },
        {
          "question": "What is the time complexity of Prim's Algorithm using an adjacency matrix?",
          "choices": [
            "A) O(n log n)",
            "B) O(n^2)",
            "C) O(n)",
            "D) O(n^3)"
          ],
          "answer": "B"
        },
        {
          "question": "Which of the following statements about Prim's Algorithm is true?",
          "choices": [
            "A) It can only be used for directed graphs",
            "B) It guarantees a unique minimum spanning tree",
            "C) It can handle graphs with negative weights",
            "D) It may not yield a minimum spanning tree if run on a disconnected graph"
          ],
          "answer": "D"
        },
        {
          "question": "What happens in each iteration of Prim's Algorithm?",
          "choices": [
            "A) A vertex is added to the minimum spanning tree",
            "B) An edge is removed from the graph",
            "C) A vertex is removed from the minimum spanning tree",
            "D) A cycle is created"
          ],
          "answer": "A"
        },
        {
          "question": "Which of the following is a disadvantage of Prim's Algorithm?",
          "choices": [
            "A) It is simple to implement",
            "B) It may require more memory for dense graphs",
            "C) It works on both directed and undirected graphs",
            "D) It guarantees an optimal solution"
          ],
          "answer": "B"
        },
        {
          "question": "What is the key idea behind Prim's Algorithm?",
          "choices": [
            "A) Build the tree from the leaves up",
            "B) Add edges with the minimum weights",
            "C) Explore all paths from the source",
            "D) Combine suboptimal solutions"
          ],
          "answer": "B"
        }
      ]
    },
    {
      "topic": "Kruskal's Algorithm",
      "questions": [
        {
          "question": "What is the primary function of Kruskal's Algorithm?",
          "choices": [
            "A) Finding the shortest path",
            "B) Finding the minimum spanning tree",
            "C) Sorting elements",
            "D) Finding the maximum flow"
          ],
          "answer": "B"
        },
        {
          "question": "Which data structure is commonly used in Kruskal's Algorithm?",
          "choices": [
            "A) Stack",
            "B) Queue",
            "C) Array",
            "D) Disjoint set"
          ],
          "answer": "D"
        },
        {
          "question": "What is the time complexity of Kruskal's Algorithm using union-find?",
          "choices": [
            "A) O(E log V)",
            "B) O(V^2)",
            "C) O(E + V)",
            "D) O(V log V)"
          ],
          "answer": "A"
        },
        {
          "question": "What does Kruskal's Algorithm use to build the minimum spanning tree?",
          "choices": [
            "A) Only the smallest edges",
            "B) The largest edges",
            "C) Edges in increasing order of weight",
            "D) Random edges"
          ],
          "answer": "C"
        },
        {
          "question": "Which of the following statements about Kruskal's Algorithm is true?",
          "choices": [
            "A) It can only be applied to directed graphs",
            "B) It can produce a minimum spanning tree even in a disconnected graph",
            "C) It does not guarantee an optimal solution",
            "D) It requires a sorted edge list"
          ],
          "answer": "D"
        },
        {
          "question": "What is the key condition that Kruskal's Algorithm checks before adding an edge?",
          "choices": [
            "A) The edge should connect two different components",
            "B) The edge should have the maximum weight",
            "C) The edge should be in the original graph",
            "D) The edge should be a loop"
          ],
          "answer": "A"
        },
        {
          "question": "Which of the following is a disadvantage of Kruskal's Algorithm?",
          "choices": [
            "A) It is easy to implement",
            "B) It may require sorting of edges",
            "C) It works on both directed and undirected graphs",
            "D) It guarantees an optimal solution"
          ],
          "answer": "B"
        }
      ]
    },
    {
      "topic": "Dijkstra's Algorithm",
      "questions": [
        {
          "question": "What is the main purpose of Dijkstra's Algorithm?",
          "choices": [
            "A) Finding the maximum flow in a graph",
            "B) Finding the shortest path in a weighted graph",
            "C) Sorting elements",
            "D) Finding the minimum spanning tree"
          ],
          "answer": "B"
        },
        {
          "question": "Which data structure is commonly used to implement Dijkstra's Algorithm?",
          "choices": [
            "A) Array",
            "B) Linked list",
            "C) Priority queue",
            "D) Stack"
          ],
          "answer": "C"
        },
        {
          "question": "What is the time complexity of Dijkstra's Algorithm using a binary heap?",
          "choices": [
            "A) O(V^2)",
            "B) O(E + V log V)",
            "C) O(V log V)",
            "D) O(E)"
          ],
          "answer": "B"
        },
        {
          "question": "Which of the following statements about Dijkstra's Algorithm is true?",
          "choices": [
            "A) It can handle negative weight edges",
            "B) It is guaranteed to find the optimal solution",
            "C) It works only on directed graphs",
            "D) It is a brute-force method"
          ],
          "answer": "B"
        },
        {
          "question": "What is the key principle behind Dijkstra's Algorithm?",
          "choices": [
            "A) Explore all paths from the source",
            "B) Use a greedy approach to build the shortest path",
            "C) Use dynamic programming to calculate distances",
            "D) Combine multiple paths to find the shortest one"
          ],
          "answer": "B"
        },
        {
          "question": "In Dijkstra's Algorithm, what does the priority queue store?",
          "choices": [
            "A) All vertices in the graph",
            "B) The distances from the source to each vertex",
            "C) The edges of the graph",
            "D) The visited vertices"
          ],
          "answer": "B"
        },
        {
          "question": "Which of the following scenarios is a limitation of Dijkstra's Algorithm?",
          "choices": [
            "A) It cannot be used in real-time applications",
            "B) It does not find the shortest path in graphs with negative weights",
            "C) It is too slow for large graphs",
            "D) It requires too much memory"
          ],
          "answer": "B"
        }
      ]
    },
    {
      "topic": "Bellman-Ford Algorithm",
      "questions": [
        {
          "question": "What is the primary purpose of the Bellman-Ford Algorithm?",
          "choices": [
            "A) Finding the minimum spanning tree",
            "B) Finding the shortest path in graphs with negative weights",
            "C) Sorting elements",
            "D) Finding the maximum flow"
          ],
          "answer": "B"
        },
        {
          "question": "What is the time complexity of the Bellman-Ford Algorithm?",
          "choices": [
            "A) O(V log V)",
            "B) O(V^2)",
            "C) O(E + V)",
            "D) O(E log E)"
          ],
          "answer": "C"
        },
        {
          "question": "Which of the following statements about the Bellman-Ford Algorithm is true?",
          "choices": [
            "A) It cannot handle negative weight cycles",
            "B) It works only on directed graphs",
            "C) It can find negative weight cycles",
            "D) It is less efficient than Dijkstra's Algorithm for all cases"
          ],
          "answer": "C"
        },
        {
          "question": "In the Bellman-Ford Algorithm, how many times is the relaxation process performed?",
          "choices": [
            "A) V - 1 times",
            "B) E times",
            "C) V times",
            "D) 2 times"
          ],
          "answer": "A"
        },
        {
          "question": "What happens if a negative weight cycle is detected in the Bellman-Ford Algorithm?",
          "choices": [
            "A) The algorithm terminates successfully",
            "B) The algorithm produces the shortest path",
            "C) The algorithm raises an error",
            "D) The algorithm cannot find a shortest path"
          ],
          "answer": "D"
        },
        {
          "question": "Which of the following is a disadvantage of the Bellman-Ford Algorithm?",
          "choices": [
            "A) It is faster than Dijkstra's Algorithm",
            "B) It can handle negative weights",
            "C) It is more complex to implement",
            "D) It requires less memory"
          ],
          "answer": "C"
        },
        {
          "question": "What is the main advantage of the Bellman-Ford Algorithm over Dijkstra's Algorithm?",
          "choices": [
            "A) It is simpler to implement",
            "B) It can handle negative weight edges",
            "C) It is faster",
            "D) It uses less memory"
          ],
          "answer": "B"
        }
      ]
    },
    {
      "topic": "Travelling Salesman Problem (TSP)",
      "questions": [
        {
          "question": "What is the Travelling Salesman Problem (TSP) concerned with?",
          "choices": [
            "A) Finding the shortest path in a graph",
            "B) Finding the longest path in a graph",
            "C) Finding the shortest route that visits all cities",
            "D) Finding the minimum spanning tree"
          ],
          "answer": "C"
        },
        {
          "question": "What type of problem is the Travelling Salesman Problem?",
          "choices": [
            "A) NP-hard problem",
            "B) P problem",
            "C) Polynomial problem",
            "D) Linear problem"
          ],
          "answer": "A"
        },
        {
          "question": "Which of the following approaches is commonly used to solve TSP?",
          "choices": [
            "A) Dynamic programming",
            "B) Brute-force search",
            "C) Greedy algorithm",
            "D) All of the above"
          ],
          "answer": "D"
        },
        {
          "question": "What is a common heuristic used in solving TSP?",
          "choices": [
            "A) Nearest neighbor",
            "B) Random sampling",
            "C) Backtracking",
            "D) Divide and conquer"
          ],
          "answer": "A"
        },
        {
          "question": "In the context of TSP, what does 'greedy' mean?",
          "choices": [
            "A) Making the best local choice at each step",
            "B) Trying all possible combinations",
            "C) Finding the longest path",
            "D) Finding the shortest path"
          ],
          "answer": "A"
        },
        {
          "question": "Which of the following is a limitation of the brute-force method for TSP?",
          "choices": [
            "A) It guarantees the optimal solution",
            "B) It is fast for small datasets",
            "C) It becomes impractical for large datasets",
            "D) It can be easily implemented"
          ],
          "answer": "C"
        },
        {
          "question": "What is the main goal of solving the Travelling Salesman Problem?",
          "choices": [
            "A) Minimize the distance traveled",
            "B) Maximize the number of cities visited",
            "C) Find the fastest route",
            "D) Minimize the time spent"
          ],
          "answer": "A"
        }
      ]
    },
    {
      "topic": "Longest Common Subsequence (LCS)",
      "questions": [
        {
          "question": "What is the Longest Common Subsequence problem concerned with?",
          "choices": [
            "A) Finding the shortest path in a graph",
            "B) Finding the longest subsequence that appears in the same relative order",
            "C) Finding the shortest substring in a string",
            "D) Finding the longest repeating character"
          ],
          "answer": "B"
        },
        {
          "question": "Which of the following algorithms can be used to solve the LCS problem?",
          "choices": [
            "A) Dynamic programming",
            "B) Greedy algorithm",
            "C) Backtracking",
            "D) Brute-force search"
          ],
          "answer": "A"
        },
        {
          "question": "What is the time complexity of the dynamic programming solution for LCS?",
          "choices": [
            "A) O(n)",
            "B) O(m + n)",
            "C) O(m * n)",
            "D) O(m^2 + n^2)"
          ],
          "answer": "C"
        },
        {
          "question": "In LCS, what does 'subsequence' mean?",
          "choices": [
            "A) A substring that appears in order",
            "B) A series of characters that are not necessarily contiguous",
            "C) A series of characters that are contiguous",
            "D) A series of characters that are reversed"
          ],
          "answer": "B"
        },
        {
          "question": "What is the primary application of LCS?",
          "choices": [
            "A) Data compression",
            "B) Bioinformatics",
            "C) Natural language processing",
            "D) All of the above"
          ],
          "answer": "D"
        },
        {
          "question": "Which of the following statements about LCS is true?",
          "choices": [
            "A) It is always a contiguous substring",
            "B) It can have multiple valid solutions",
            "C) It can only be used for numerical sequences",
            "D) It has a fixed time complexity"
          ],
          "answer": "B"
        },
        {
          "question": "What is the first step in solving the LCS problem using dynamic programming?",
          "choices": [
            "A) Initialize the table",
            "B) Calculate the length of the LCS",
            "C) Compare characters of both sequences",
            "D) Build the subsequence"
          ],
          "answer": "A"
        }
      ]
    },
    {
      "topic": "Matrix Chain Multiplication",
      "questions": [
        {
          "question": "What is the goal of the Matrix Chain Multiplication problem?",
          "choices": [
            "A) Minimize the number of matrix multiplications",
            "B) Maximize the number of matrices",
            "C) Find the fastest algorithm",
            "D) Optimize memory usage"
          ],
          "answer": "A"
        },
        {
          "question": "Which of the following methods can be used to solve the Matrix Chain Multiplication problem?",
          "choices": [
            "A) Greedy algorithm",
            "B) Dynamic programming",
            "C) Backtracking",
            "D) Brute-force search"
          ],
          "answer": "B"
        },
        {
          "question": "What is the time complexity of the dynamic programming solution for Matrix Chain Multiplication?",
          "choices": [
            "A) O(n)",
            "B) O(n^2)",
            "C) O(n^3)",
            "D) O(2^n)"
          ],
          "answer": "C"
        },
        {
          "question": "In Matrix Chain Multiplication, what is meant by 'chain'?",
          "choices": [
            "A) A series of matrices that need to be multiplied",
            "B) A series of scalars",
            "C) A continuous array",
            "D) A sequence of operations"
          ],
          "answer": "A"
        },
        {
          "question": "Which of the following is true regarding the Matrix Chain Multiplication problem?",
          "choices": [
            "A) It requires a fixed number of matrices",
            "B) It can be solved using a brute-force approach",
            "C) It has a unique optimal solution",
            "D) It is easy to solve with only two matrices"
          ],
          "answer": "C"
        },
        {
          "question": "What is the first step in solving the Matrix Chain Multiplication problem?",
          "choices": [
            "A) Initialize a table to store results",
            "B) Compare matrices",
            "C) Calculate the order of multiplication",
            "D) Multiply the first two matrices"
          ],
          "answer": "A"
        },
        {
          "question": "What is the primary advantage of dynamic programming for solving the Matrix Chain Multiplication problem?",
          "choices": [
            "A) It requires less memory",
            "B) It guarantees an optimal solution",
            "C) It is simpler to implement",
            "D) It runs faster than all other methods"
          ],
          "answer": "B"
        }
      ]
    },
    {
      "topic": "0/1 Knapsack",
      "questions": [
        {
          "question": "What is the main characteristic of the 0/1 Knapsack problem?",
          "choices": [
            "A) Items can be divided",
            "B) Items can only be either taken or left behind",
            "C) Items can be weighted",
            "D) It requires a fixed number of items"
          ],
          "answer": "B"
        },
        {
          "question": "Which of the following methods can be used to solve the 0/1 Knapsack problem?",
          "choices": [
            "A) Greedy algorithm",
            "B) Dynamic programming",
            "C) Backtracking",
            "D) All of the above"
          ],
          "answer": "B"
        },
        {
          "question": "What is the time complexity of the dynamic programming solution for the 0/1 Knapsack problem?",
          "choices": [
            "A) O(n)",
            "B) O(n^2)",
            "C) O(n * W)",
            "D) O(W^2)"
          ],
          "answer": "C"
        },
        {
          "question": "What is the main objective of the 0/1 Knapsack problem?",
          "choices": [
            "A) Maximize the total weight",
            "B) Minimize the total weight",
            "C) Maximize the total value while staying within the weight limit",
            "D) Minimize the total value"
          ],
          "answer": "C"
        },
        {
          "question": "Which of the following statements about the 0/1 Knapsack problem is true?",
          "choices": [
            "A) It can have multiple optimal solutions",
            "B) It is a polynomial time problem",
            "C) It can be solved using only a greedy approach",
            "D) It can be solved in linear time"
          ],
          "answer": "A"
        },
        {
          "question": "What is the first step in solving the 0/1 Knapsack problem using dynamic programming?",
          "choices": [
            "A) Initialize a table to store results",
            "B) Compare values",
            "C) Calculate the total weight",
            "D) Select the items to include"
          ],
          "answer": "A"
        },
        {
          "question": "What is the primary advantage of dynamic programming for solving the 0/1 Knapsack problem?",
          "choices": [
            "A) It is faster than brute-force methods",
            "B) It requires less memory",
            "C) It guarantees an optimal solution",
            "D) It is simpler to implement"
          ],
          "answer": "C"
        }
      ]
    },
    {
      "topic": "Huffman Coding",
      "questions": [
        {
          "question": "What is the main purpose of Huffman coding?",
          "choices": [
            "A) Data compression",
            "B) Sorting data",
            "C) Encrypting data",
            "D) Data retrieval"
          ],
          "answer": "A"
        },
        {
          "question": "Which data structure is primarily used in Huffman coding?",
          "choices": [
            "A) Stack",
            "B) Queue",
            "C) Binary tree",
            "D) Array"
          ],
          "answer": "C"
        },
        {
          "question": "What is the time complexity of building a Huffman tree?",
          "choices": [
            "A) O(n log n)",
            "B) O(n^2)",
            "C) O(n)",
            "D) O(log n)"
          ],
          "answer": "A"
        },
        {
          "question": "What is the key principle behind Huffman coding?",
          "choices": [
            "A) Assigning fixed-length codes to characters",
            "B) Assigning variable-length codes based on frequency",
            "C) Using random codes for data",
            "D) Encrypting data with keys"
          ],
          "answer": "B"
        },
        {
          "question": "Which of the following is a disadvantage of Huffman coding?",
          "choices": [
            "A) It can be used for any type of data",
            "B) It requires a lot of memory",
            "C) It is not suitable for small files",
            "D) It is complex to implement"
          ],
          "answer": "C"
        },
        {
          "question": "In Huffman coding, what happens if two characters have the same frequency?",
          "choices": [
            "A) They are assigned the same code",
            "B) One is randomly chosen to represent both",
            "C) They are combined into a single node",
            "D) One is given a longer code"
          ],
          "answer": "C"
        },
        {
          "question": "What is the first step in building a Huffman tree?",
          "choices": [
            "A) Create a priority queue of all characters",
            "B) Sort the characters by frequency",
            "C) Build the tree bottom-up",
            "D) Assign codes to characters"
          ],
          "answer": "A"
        }
      ]
    },
    {
      "topic": "Fractional Knapsack",
      "questions": [
        {
          "question": "What is the main difference between the 0/1 Knapsack and the Fractional Knapsack problem?",
          "choices": [
            "A) Items can be divided in the Fractional Knapsack",
            "B) The Fractional Knapsack has a fixed number of items",
            "C) The 0/1 Knapsack can have fractional weights",
            "D) The Fractional Knapsack can only take one item"
          ],
          "answer": "A"
        },
        {
          "question": "Which of the following approaches is used to solve the Fractional Knapsack problem?",
          "choices": [
            "A) Dynamic programming",
            "B) Greedy algorithm",
            "C) Brute-force search",
            "D) Backtracking"
          ],
          "answer": "B"
        },
        {
          "question": "What is the time complexity of the greedy solution for the Fractional Knapsack problem?",
          "choices": [
            "A) O(n^2)",
            "B) O(n log n)",
            "C) O(n)",
            "D) O(n^3)"
          ],
          "answer": "B"
        },
        {
          "question": "What is the primary objective of the Fractional Knapsack problem?",
          "choices": [
            "A) Minimize the total weight",
            "B) Maximize the total value",
            "C) Find the optimal weight",
            "D) Maximize the number of items"
          ],
          "answer": "B"
        },
        {
          "question": "Which of the following statements about the Fractional Knapsack problem is true?",
          "choices": [
            "A) It is an NP-hard problem",
            "B) It can have multiple optimal solutions",
            "C) It can only be solved using dynamic programming",
            "D) It can be solved in linear time"
          ],
          "answer": "D"
        },
        {
          "question": "What is the first step in solving the Fractional Knapsack problem using a greedy approach?",
          "choices": [
            "A) Sort items by weight",
            "B) Sort items by value",
            "C) Calculate the value-to-weight ratio",
            "D) Select the items to include"
          ],
          "answer": "C"
        },
        {
          "question": "What is the optimal solution of the Fractional Knapsack problem?",
          "choices": [
            "A) The highest total weight",
            "B) The highest total value",
            "C) A balance of weight and value",
            "D) The lowest total weight"
          ],
          "answer": "B"
        }
      ]
    }
  ]
}
